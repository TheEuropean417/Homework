<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>AEGIS CORE — Orbital Commandlike (v3)</title>
<style>
  :root{
    --bg:#070b16;--bg2:#0c1226;--ink:#e6ecff;--ink-dim:#9aa5c3;
    --a:#64d2ff;--b:#a56bff;--good:#3cff9e;--bad:#ff5f7a;--warn:#ffc658;
    --glass: rgba(255,255,255,.06); --glass-strong: rgba(255,255,255,.12);
    --shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background: radial-gradient(1400px 900px at 70% 0%, var(--bg2), var(--bg)); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans");}
  #wrap{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr}
  header{height:48px; display:flex; align-items:center; justify-content:space-between; padding:8px 12px; color:var(--ink-dim); user-select:none}
  header .brand{letter-spacing:.18em; font-weight:800; color:var(--ink); font-size:14px}
  header .brand b{color:var(--a)}
  header .btn{border:1px solid var(--glass-strong); border-radius:10px; padding:6px 10px; background:var(--glass); color:var(--ink); cursor:pointer; transition:.2s; backdrop-filter: blur(6px);}
  header .btn:hover{transform:translateY(-1px); box-shadow:0 2px 16px rgba(95,210,255,.25)}
  #game{width:100%; height:100%; display:block;}

  /* HUD */
  #hud{position:fixed; inset:48px 0 0 0; pointer-events:none; font-size:12px}
  #hud .top{position:absolute; top:8px; left:12px; display:flex; gap:10px; align-items:center}
  #hud .pill{pointer-events:auto; padding:6px 10px; border-radius:999px; background:var(--glass); border:1px solid var(--glass-strong); backdrop-filter: blur(4px);}
  .meter{position:relative; width:160px; height:10px; border-radius:6px; background:rgba(255,255,255,.08); overflow:hidden; border:1px solid rgba(255,255,255,.1)}
  .meter.small{width:120px}
  .meter .fill{position:absolute; inset:0; width:0%; background:linear-gradient(90deg,var(--a),var(--b)); box-shadow:0 0 12px rgba(95,210,255,.6) inset}
  #hud .right{position:absolute; top:8px; right:12px; display:flex; gap:8px}
  #hud .legend{position:absolute; left:12px; bottom:18px; display:flex; flex-direction:column; gap:6px; width:min(620px, calc(100% - 24px))}
  .legend .row{display:flex; align-items:center; gap:8px; padding:6px 8px; border-radius:10px; background:var(--glass); border:1px solid var(--glass-strong); backdrop-filter: blur(4px);}
  .legend .key{padding:2px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06); font-family:ui-monospace,monospace}
  .legend .locked{opacity:.5}
  .legend .active{box-shadow:0 0 0 2px rgba(100,210,255,.35) inset}
  #hud .tip{position:absolute; bottom:18px; right:12px; opacity:.8}
  #hud .core{position:absolute; top:44px; left:50%; transform:translateX(-50%); opacity:.9}

  /* Overlay / Panel */
  #overlay{position:fixed; inset:48px 0 0 0; display:none; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(10,15,31,.0), rgba(10,15,31,.55) 10%, rgba(10,15,31,.75)); backdrop-filter: blur(6px); }
  #overlay.show{display:flex}
  .panel{width:min(900px, calc(100% - 32px)); max-height:calc(100% - 64px); overflow:auto; background:var(--glass); border:1px solid var(--glass-strong); border-radius:18px; padding:18px; box-shadow: var(--shadow)}
  .grid{display:grid; grid-template-columns: 1fr 1fr; gap:18px}
  .big-title{font-size:22px; font-weight:900; letter-spacing:.16em; margin:6px 0 14px; color:var(--ink)}
  .subtitle{margin-top:8px; color:var(--ink-dim)}
  .btn-row{display:flex; gap:10px; flex-wrap:wrap}
  .cta{cursor:pointer; padding:12px 14px; border-radius:12px; border:1px solid var(--glass-strong); background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); transition:.15s}
  .cta.primary{background:linear-gradient(180deg, rgba(95,210,255,.22), rgba(95,210,255,.08)); border-color: rgba(95,210,255,.35); color:#07121d; font-weight:800}
  .section{padding:12px 0; border-top:1px dashed rgba(255,255,255,.12); margin-top:10px}
  .row{display:flex; gap:10px; align-items:center; justify-content:space-between; padding:8px 0; border-bottom:1px dashed rgba(255,255,255,.08)}
  .row:last-child{border-bottom:none}
  .tag{padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); font-size:11px; letter-spacing:.08em}
  .muted{opacity:.7}
  .kbd{padding:3px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06); font-family:ui-monospace,monospace; font-size:12px}
  @media (max-width:760px){ .grid{grid-template-columns:1fr} }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="brand">AEGIS<b>CORE</b> // ORBITAL COMMANDLIKE</div>
    <div>
      <button id="menuBtn" class="btn" title="Menu / Pause (Esc)">☰ Menu</button>
    </div>
  </header>

  <canvas id="game" aria-label="Aegis Core playfield"></canvas>

  <!-- HUD -->
  <div id="hud">
    <div class="top">
      <div class="pill"><span class="muted">Score</span> · <b id="score">0</b></div>
      <div class="pill"><span class="muted">Wave</span> · <b id="wave">1</b></div>
      <div class="pill"><span class="muted">Kills</span> · <b id="kills">0</b></div>
      <div class="pill"><span class="muted">Tech</span> · <b id="tech">0</b></div>
      <div class="pill"><span class="muted">Overclock</span>
        <div class="meter small"><div id="focusFill" class="fill"></div></div>
      </div>
    </div>
    <div class="right">
      <div class="pill"><span class="muted">Best</span> · <b id="best">0</b></div>
      <div class="pill"><span class="muted">Integrity</span> · <b id="hp">▣▣▣</b></div>
    </div>

    <div class="core muted">
      Controls: Click deploy • <span class="kbd">Q/E</span> switch • <span class="kbd">1–5</span> select •
      <span class="kbd">Shift</span> Overclock • <span class="kbd">F</span> Fullscreen • <span class="kbd">Esc</span> Pause
    </div>

    <!-- Weapon Legend -->
    <div id="legend" class="legend"></div>

    <div class="tip muted">Detonate inside faint resonance rings to amplify blast radius & score.</div>
  </div>

  <!-- Overlay / Menu -->
  <div id="overlay" role="dialog" aria-modal="true">
    <div class="panel">
      <div class="big-title">AEGIS CORE</div>
      <div class="subtitle">360° orbital defense with formula‑driven Tech upgrades—no pickups, only kills. Bigger blasts, nova shockwaves, dual rails, lockdown nets, and singularities.</div>

      <div class="section">
        <div class="btn-row">
          <button class="cta primary" id="playBtn">▶ Play (Endless)</button>
          <button class="cta" id="howBtn">? How to</button>
          <button class="cta" id="setBtn">⚙ Settings</button>
          <button class="cta" id="resetBtn" title="Reset saved progress">⟲ Reset Save</button>
        </div>
      </div>

      <div class="grid">
        <div class="section">
          <div class="big-title">Settings</div>
          <div id="settings"></div>
        </div>
        <div class="section">
          <div class="big-title">Stats</div>
          <div id="stats"></div>
        </div>
      </div>

      <div class="section">
        <div class="big-title">How to Play</div>
        <div class="subtitle">
          Enemies stream from the perimeter toward your central <b>Core</b>. Click to deploy your active weapon; switch with <b>Q/E</b> or <b>1–5</b>.
          Kills raise <b>Tech</b> and deterministically upgrade weapons. There are no pickups or random powerups.
          Use <b>Overclock</b> (<span class="kbd">Shift</span>) to slow time when charged. Press <span class="kbd">F</span> for fullscreen.
        </div>
      </div>
      <div class="section muted" style="font-size:12px">
        <span class="tag">No Audio</span> This build intentionally includes no sound or music.
        <span class="tag">Persistence</span> Uses localStorage for best score & settings.
        <span class="tag">Version</span> 3.0
      </div>
    </div>
  </div>
</div>

<script>
/* ===========================
   AEGIS CORE v3 — Orbital Commandlike
   Upgrades are formula-driven, strictly kill-gated, and monotonic:
     - Tech level L = floor(kills / 20)
     - Each weapon’s stats derive from L; big feature toggles at breakpoints.
   Weapons:
     1) Pulse Bomb (explosive; huge radius; echoes at higher Tech)
     2) Nova Ring (expanding shockwave ring)
     3) Rail Lance (beam; dual rails at higher Tech)
     4) Lockdown Net (expanding lattice; slows → roots at high Tech)
     5) Singularity (gravity well → massive blast)
   No audio. Fullscreen with 'F'.
   =========================== */

/* ---------- Utilities ---------- */
const TAU = Math.PI*2;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const easeOutQuad=t=>1-(1-t)*(1-t);
const dist2=(x1,y1,x2,y2)=>{const dx=x2-x1,dy=y2-y1;return dx*dx+dy*dy;}
function hsl(h,s,l,a=1){return `hsla(${h},${s}%,${l}%,${a})`}

// Mulberry32 deterministic RNG
function mulberry32(seed){ let t=seed>>>0; return function(){ t+=0x6D2B79F5; t=Math.imul(t^(t>>>15),t|1); t^=t+Math.imul(t^(t>>>7),t|61); return ((t^(t>>>14))>>>0)/4294967296; } }
function strToSeed(s){ let h=2166136261>>>0; for(let i=0;i<s.length;i++){h^=s.charCodeAt(i); h=Math.imul(h,16777619);} return h>>>0; }

/* ---------- Save ---------- */
const SAVE_KEY='aegis_core_v3';
let SAVE = JSON.parse(localStorage.getItem(SAVE_KEY)||'{}');
if(!SAVE.settings){ SAVE.settings = { particles:true, shake:true, colorblind:false, flashes:true, difficulty:'normal' }; }
if(!SAVE.stats){ SAVE.stats = { games:0, best:0, totalScore:0, totalKills:0 }; }

/* ---------- Canvas ---------- */
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
let DPR=Math.max(1,Math.min(2.5, window.devicePixelRatio||1));
function resize(){
  const r=canvas.getBoundingClientRect();
  canvas.width=Math.floor(r.width*DPR);
  canvas.height=Math.floor(r.height*DPR);
  CORE.x=canvas.width/2; CORE.y=canvas.height/2;
}
addEventListener('resize', resize);

/* ---------- HUD ---------- */
const $=s=>document.querySelector(s);
const scoreEl=$('#score'), waveEl=$('#wave'), bestEl=$('#best'), killsEl=$('#kills'), hpEl=$('#hp'), techEl=$('#tech'), focusFill=$('#focusFill');
const legendEl=$('#legend');

/* ---------- Game State ---------- */
const CORE={x:0,y:0,r:22, integrity:3};
const GAME={
  state:'menu',
  rng: mulberry32(strToSeed('endless')),
  seed:'endless',
  t:0, last:performance.now(),
  score:0, wave:1,
  kills:0,
  arrays:{ enemies:[], bombs:[], explosions:[], beams:[], nets:[], wells:[], particles:[], resonances:[], flashes:[], waves:[] },
  focus:0, focusMax:100, focusActive:false,
  director:{ t:0, spawnT:0, every:1.0, sMin:80, sMax:160 },
  weapons:{
    order:['pulse','nova','rail','net','singularity'],
    unlocked:new Set(['pulse']),
    active:'pulse',
    cd:{pulse:0, nova:0, rail:0, net:0, singularity:0}
  },
  tech:{ level:0, mods:{}, flags:{} },
  camera:{shake:0}
};
CORE.r = 22*DPR;

/* ---------- Unlocks & Tech formulas ---------- */
// Unlock thresholds are absolute kills (no RNG).
const UNLOCKS = [
  {kills:0,    id:'pulse'},
  {kills:15,   id:'nova'},
  {kills:35,   id:'rail'},
  {kills:60,   id:'net'},
  {kills:100,  id:'singularity'}
];
// Tech level L = floor(kills/20). Stats derive from L:
function recomputeTech(){
  const L = Math.floor(GAME.kills/20);
  if(L!==GAME.tech.level){
    GAME.tech.level=L;
  }
  // strictly increasing or tightening parameters
  GAME.tech.mods = {
    // Pulse explosion multiplier (base radius * this)
    pulseMult: 1.0 + 0.12*Math.min(L,7) + 0.02*Math.max(0,L-7), // gentle taper at high L
    // Nova shockwave
    waveSpeed: 260 + 18*L,
    waveThick: (12 + 1.2*L)*DPR,
    // Rail
    railWidth: Math.min(24, 10 + 2*L)*DPR,
    // Net
    netSlow: Math.max(0.30, 0.55 - 0.02*L), // lower is stronger
    // Singularity
    wellPull: 140 + 18*L,
    finalBlastMult: 1.0 + 0.08*L // final pop scales
  };
  GAME.tech.flags = {
    pulseEcho: L>=4,         // Pulse spawns a nova ring echo
    waveDouble: L>=7,        // Nova spawns a delayed second ring
    railDual:  L>=9,         // Two rails with slight spread
    netRoot:   L>=11 ? 0.35 : 0 // Net briefly roots near center (seconds)
  };
  // Ensure unlocks based on kills
  for(const u of UNLOCKS){ if(GAME.kills>=u.kills) GAME.weapons.unlocked.add(u.id); }
  renderLegend();
}

// Cooldowns scale down with level; Singularity scales less so.
const BASE_CD = { pulse:0.45, nova:1.6, rail:2.0, net:3.0, singularity:5.2 };
function cooldownFor(id){
  const L = GAME.tech.level;
  const base = BASE_CD[id];
  const perLevel = (id==='singularity') ? 0.985 : 0.96; // singularity cools slower
  return base * Math.pow(perLevel, L);
}
function setCooldown(id){ GAME.weapons.cd[id]=cooldownFor(id); }

/* ---------- Settings Panel ---------- */
function renderSettings(){
  const S=SAVE.settings;
  $('#settings').innerHTML=`
    <div class="row"><div>Particles</div><div><input type="checkbox" id="setParticles" ${S.particles?'checked':''}></div></div>
    <div class="row"><div>Screen Shake</div><div><input type="checkbox" id="setShake" ${S.shake?'checked':''}></div></div>
    <div class="row"><div>Flashes</div><div><input type="checkbox" id="setFlashes" ${S.flashes?'checked':''}></div></div>
    <div class="row"><div>Colorblind palette</div><div><input type="checkbox" id="setCB" ${S.colorblind?'checked':''}></div></div>
    <div class="row"><div>Difficulty</div><div>
      <select id="setDiff">
        <option ${S.difficulty==='relaxed'?'selected':''} value="relaxed">Relaxed</option>
        <option ${S.difficulty==='normal'?'selected':''} value="normal">Normal</option>
        <option ${S.difficulty==='hard'?'selected':''} value="hard">Hard</option>
      </select>
    </div></div>
  `;
  $('#setParticles').onchange=e=>{ S.particles=e.target.checked; saveAll(); };
  $('#setShake').onchange=e=>{ S.shake=e.target.checked; saveAll(); };
  $('#setFlashes').onchange=e=>{ S.flashes=e.target.checked; saveAll(); };
  $('#setCB').onchange=e=>{ S.colorblind=e.target.checked; applyPalette(); saveAll(); };
  $('#setDiff').onchange=e=>{ S.difficulty=e.target.value; saveAll(); };
}
function renderStats(){
  const st=SAVE.stats;
  $('#stats').innerHTML=`
    <div class="row"><div>Games Played</div><div>${st.games|0}</div></div>
    <div class="row"><div>Best Score</div><div>${st.best|0}</div></div>
    <div class="row"><div>Total Score</div><div>${st.totalScore|0}</div></div>
    <div class="row"><div>Total Kills</div><div>${st.totalKills|0}</div></div>
  `;
}
function applyPalette(){
  if(SAVE.settings.colorblind){
    document.documentElement.style.setProperty('--a','#7bd389');
    document.documentElement.style.setProperty('--b','#4ea1ff');
    document.documentElement.style.setProperty('--good','#00d08a');
    document.documentElement.style.setProperty('--bad','#ff6b6b');
  }else{
    document.documentElement.style.setProperty('--a','#64d2ff');
    document.documentElement.style.setProperty('--b','#a56bff');
    document.documentElement.style.setProperty('--good','#3cff9e');
    document.documentElement.style.setProperty('--bad','#ff5f7a');
  }
}

/* ---------- Input ---------- */
let mouse={x:0,y:0, down:false};
canvas.addEventListener('mousemove', e=>{ const b=canvas.getBoundingClientRect(); mouse.x=(e.clientX-b.left)*DPR; mouse.y=(e.clientY-b.top)*DPR; }, {passive:true});
canvas.addEventListener('mousedown', e=>{ e.preventDefault(); if(e.button===0){ fireActive(mouse.x, mouse.y); } }, {passive:false});
addEventListener('contextmenu', e=>{ e.preventDefault(); });

let keys={};
addEventListener('keydown', e=>{
  const k=e.key.toLowerCase(); keys[k]=true;
  if(k==='escape'){ toggleMenu(); }
  if(k==='shift'){ tryOverclock(); }
  if(k==='f'){ toggleFullscreen(); }
  if(k==='q'){ cycleWeapon(-1); }
  if(k==='e'){ cycleWeapon(1); }
  if('12345'.includes(k)){ selectWeapon(parseInt(k)); }
});
addEventListener('keyup', e=>{ keys[e.key.toLowerCase()]=false; });

function toggleFullscreen(){
  if(!document.fullscreenElement){ document.documentElement.requestFullscreen?.({navigationUI:'hide'}); }
  else{ document.exitFullscreen?.(); }
}

/* ---------- Camera Shake ---------- */
function cameraShake(str){ if(!SAVE.settings.shake) return; GAME.camera.shake=Math.max(GAME.camera.shake, str); }

/* ---------- Entities ---------- */
class Enemy{
  constructor(x,y,vx,vy,type='meteor',hp=1, speed=120){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.type=type; this.hp=hp; this.baseSpeed=speed;
    this.r=(type==='shield'?9:7)*DPR; this.age=0; this.alive=true;
  }
  update(dt){
    this.age+=dt;
    // behaviors
    if(this.type==='dasher'){
      const d=Math.hypot(this.x-CORE.x, this.y-CORE.y);
      const mult = d<200*DPR?1.7:1.0;
      this.x+=this.vx*dt*mult; this.y+=this.vy*dt*mult;
    }else if(this.type==='splitter'){
      this.x+=this.vx*dt; this.y+=this.vy*dt;
      this.x+=Math.sin(this.age*5)*(10*dt);
      this.y+=Math.cos(this.age*6)*(8*dt);
    }else{
      this.x+=this.vx*dt; this.y+=this.vy*dt;
    }

    // reached core?
    const d2c=dist2(this.x,this.y, CORE.x, CORE.y);
    if(d2c <= (CORE.r+this.r)*(CORE.r+this.r)){
      CORE.integrity=Math.max(0, CORE.integrity-1);
      this.alive=false;
      cameraShake(10);
      if(SAVE.settings.flashes){ flashRing(CORE.x, CORE.y, CORE.r*2); }
    }
  }
  hit(dmg=1){
    this.hp-=dmg;
    if(this.hp<=0) this.kill();
  }
  kill(){
    if(!this.alive) return;
    this.alive=false;
    GAME.kills++; SAVE.stats.totalKills++;
    GAME.score += 10;
    recomputeTech();
    particleBurst(this.x,this.y, 10, 'kill');
    // splitter spawns fragments
    if(this.type==='splitter'){
      const n=3;
      for(let i=0;i<n;i++){
        const ang = Math.atan2(CORE.y-this.y, CORE.x-this.x) + (i-1)*0.35;
        const spd = (this.baseSpeed*0.85) * (0.9 + GAME.rng()*0.2);
        const vx=Math.cos(ang)*spd, vy=Math.sin(ang)*spd;
        spawnEnemy(this.x,this.y, vx, vy, 'meteor', 1, spd);
      }
    }
  }
  draw(){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    const c = (this.type==='shield')?'rgba(255,198,88,.9)':'rgba(255,98,162,.9)';
    ctx.shadowBlur=14; ctx.shadowColor=c; ctx.fillStyle=c;
    ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,TAU); ctx.fill();
    ctx.restore();
  }
}

/* --- Weapons / Effects --- */
class Bomb{
  constructor(x,y,tx,ty){
    this.x=x; this.y=y; this.tx=tx; this.ty=ty;
    const dx=tx-x, dy=ty-y, len=Math.hypot(dx,dy)||1;
    const spd=360; this.vx=dx/len*spd; this.vy=dy/len*spd;
    this.alive=true; this.age=0; this.maxAge=5;
  }
  update(dt){
    this.age+=dt; if(this.age>this.maxAge){ this.alive=false; return; }
    this.x+=this.vx*dt; this.y+=this.vy*dt;
    if(dist2(this.x,this.y,this.tx,this.ty) < (16*DPR)*(16*DPR)){
      this.explode();
    }
  }
  draw(){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.shadowBlur=18; ctx.shadowColor='rgba(100,210,255,.9)';
    ctx.fillStyle='rgba(100,210,255,.9)'; ctx.beginPath(); ctx.arc(this.x,this.y,2.2*DPR,0,TAU); ctx.fill();
    ctx.restore();
    ctx.strokeStyle='rgba(165,107,255,.35)'; ctx.lineWidth=1*DPR;
    ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(this.x-this.vx*0.06,this.y-this.vy*0.06); ctx.stroke();
  }
  explode(){
    if(!this.alive) return;
    this.alive=false;
    spawnExplosion(this.x,this.y,true);
    if(GAME.tech.flags.pulseEcho){ // pulse emits a nova echo at higher tech
      GAME.arrays.waves.push(new ShockWave(this.x,this.y,{r0:14*DPR}));
    }
  }
}
class Explosion{
  constructor(x,y,chainBoost=0){
    this.x=x; this.y=y; this.t=0; this.life=0.6;
    const base=100*DPR; // large baseline
    const r = base * GAME.tech.mods.pulseMult;
    this.rMax = clamp(r * (1 + 0.25*chainBoost), base*0.9, base*3.2);
    this.r=1; this.alive=true;
  }
  update(dt){
    this.t+=dt;
    const p=clamp(this.t/this.life,0,1);
    this.r=this.rMax*easeOutQuad(Math.min(1,p*1.4));
    if(this.t>this.life) this.alive=false;
    // leave resonance near peak
    if(Math.abs(this.r - this.rMax) < 0.6 && this.t < this.life*0.8){
      spawnResonance(this.x,this.y,this.rMax*0.8);
    }
  }
  draw(){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    const a=1-(this.t/this.life);
    const g=ctx.createRadialGradient(this.x,this.y,this.r*0.15,this.x,this.y,this.r);
    g.addColorStop(0,`rgba(165,107,255,${.22*a})`);
    g.addColorStop(0.6,`rgba(100,210,255,${.18*a})`);
    g.addColorStop(1,`rgba(100,210,255,0)`);
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,TAU); ctx.fill();
    ctx.restore();
  }
}
// Expanding shockwave ring (Nova)
class ShockWave{
  constructor(x,y,opts={}){
    this.x=x; this.y=y; this.t=0; this.life=0.9; this.alive=true;
    this.r=opts.r0 || 6*DPR;
    this.speed = GAME.tech.mods.waveSpeed;
    this.thick = GAME.tech.mods.waveThick;
    this.secondDelay = (GAME.tech.flags.waveDouble && !opts.secondary) ? 0.12 : null;
  }
  update(dt){
    this.t+=dt; this.r += this.speed*dt;
    // damage on ring contact
    for(const en of GAME.arrays.enemies){
      if(!en.alive) continue;
      const d=Math.hypot(en.x-this.x,en.y-this.y);
      if(Math.abs(d - this.r) <= this.thick*0.55){ en.hit(2); GAME.score+=4; }
    }
    if(this.secondDelay!=null){
      this.secondDelay-=dt; if(this.secondDelay<=0){ this.secondDelay=null; GAME.arrays.waves.push(new ShockWave(this.x,this.y,{r0:this.r*0.6,secondary:true})); }
    }
    if(this.t>=this.life || this.r>Math.max(canvas.width,canvas.height)) this.alive=false;
  }
  draw(){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.lineWidth=this.thick; ctx.strokeStyle='rgba(100,210,255,.55)';
    ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,TAU); ctx.stroke();
    ctx.restore();
  }
}

class RailBeam{
  constructor(x0,y0,x1,y1){
    this.x0=x0; this.y0=y0; this.x1=x1; this.y1=y1;
    this.t=0; this.life=0.12; this.alive=true;
    this.width=GAME.tech.mods.railWidth;
    // apply immediate damage to enemies crossing
    for(const en of GAME.arrays.enemies){
      if(!en.alive) continue;
      const d = pointToSegmentDist(en.x,en.y, x0,y0, x1,y1);
      if(d <= en.r + this.width*0.5){ en.hit(2); GAME.score+=6; }
    }
  }
  update(dt){ this.t+=dt; if(this.t>this.life) this.alive=false; }
  draw(){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.lineWidth=this.width; ctx.strokeStyle='rgba(100,210,255,.85)';
    ctx.beginPath(); ctx.moveTo(this.x0,this.y0); ctx.lineTo(this.x1,this.y1); ctx.stroke();
    ctx.restore();
  }
}
class NetField{
  constructor(x,y){
    this.x=x; this.y=y; this.t=0; this.life=1.7; this.alive=true;
    this.r=0; this.rMax=170*DPR;
    this.slow=GAME.tech.mods.netSlow; // 0.55 .. 0.30
    this.tick=0;
  }
  update(dt){
    this.t+=dt; const p=clamp(this.t/this.life,0,1);
    this.r=this.rMax*easeOutQuad(Math.min(1,p*1.2));
    this.tick+=dt;
    const rootWindow = GAME.tech.flags.netRoot; // seconds at start where root is active near center
    for(const en of GAME.arrays.enemies){
      if(!en.alive) continue;
      const d2e=dist2(en.x,en.y,this.x,this.y);
      if(d2e <= (this.r+en.r)*(this.r+en.r)){
        // slow everywhere in the net
        en.x -= en.vx*dt*(1-this.slow);
        en.y -= en.vy*dt*(1-this.slow);
        // root near the center during early window
        if(rootWindow && this.t<rootWindow){
          const d=Math.sqrt(d2e);
          if(d <= this.r*0.33){
            en.x -= en.vx*dt; en.y -= en.vy*dt; // force near-stasis
          }
        }
        if(this.tick>=0.16){ en.hit(1); GAME.score+=2; }
      }
    }
    if(this.tick>=0.16) this.tick=0;
    if(this.t>this.life) this.alive=false;
  }
  draw(){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.lineWidth=1.4*DPR; ctx.strokeStyle='rgba(100,210,255,.45)';
    ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,TAU); ctx.stroke();
    // lattice arms
    for(let i=0;i<6;i++){
      const a=i*(TAU/6);
      ctx.beginPath();
      ctx.moveTo(this.x+Math.cos(a)*this.r, this.y+Math.sin(a)*this.r);
      ctx.lineTo(this.x+Math.cos(a+TAU/2)*this.r, this.y+Math.sin(a+TAU/2)*this.r);
      ctx.stroke();
    }
    ctx.restore();
  }
}
class Well{
  constructor(x,y){
    this.x=x; this.y=y; this.t=0; this.life=1.05; this.alive=true; this.pull=GAME.tech.mods.wellPull;
    this.r=26*DPR;
  }
  update(dt){
    this.t+=dt;
    this.r = 38*DPR + this.t/this.life * 130*DPR;
    for(const en of GAME.arrays.enemies){
      if(!en.alive) continue;
      const dx=this.x-en.x, dy=this.y-en.y;
      const d=Math.hypot(dx,dy)||1;
      if(d<this.r*1.2){
        const f=(this.pull/d)*dt; // stronger with Tech
        en.vx+=dx/d*f; en.vy+=dy/d*f;
      }
    }
    if(this.t>=this.life){
      this.alive=false;
      // final blast scales with Tech
      const ex = new Explosion(this.x,this.y,0);
      ex.rMax *= GAME.tech.mods.finalBlastMult;
      GAME.arrays.explosions.push(ex);
      cameraShake(8);
    }
  }
  draw(){
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.lineWidth=1.6*DPR; ctx.strokeStyle='rgba(165,107,255,.7)';
    ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,TAU); ctx.stroke();
    ctx.restore();
  }
}

/* ---------- Geometry helpers ---------- */
function pointToSegmentDist(x,y, x1,y1, x2,y2){
  const dx=x2-x1, dy=y2-y1;
  const l2=dx*dx+dy*dy; if(l2===0) return Math.hypot(x-x1,y-y1);
  let t=((x-x1)*dx + (y-y1)*dy)/l2; t=clamp(t,0,1);
  const px=x1+t*dx, py=y1+t*dy;
  return Math.hypot(x-px,y-py);
}

/* ---------- FX ---------- */
function particleBurst(x,y,n,mode='kill'){
  if(!SAVE.settings.particles) return;
  for(let i=0;i<n;i++){
    const a = GAME.rng()*TAU, sp = (mode==='kill'? (40+GAME.rng()*100):(30+GAME.rng()*70));
    GAME.arrays.particles.push({x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, t:0, life:.8, size:(mode==='kill'?2:1.6)*DPR, mode});
  }
}
function flashRing(x,y,r){ GAME.arrays.flashes.push({x,y,r, t:0, life:.2}); }

/* ---------- Resonance ---------- */
function spawnResonance(x,y,r){ GAME.arrays.resonances.push({x,y,r,t:0,life:3}); }

/* ---------- Director & Spawning ---------- */
function randomEnemyType(){
  const r=GAME.rng();
  if(r<0.58) return 'meteor';
  if(r<0.76) return 'splitter';
  if(r<0.92) return 'dasher';
  return 'shield';
}
function spawnEnemy(sx,sy,vx,vy,type,hp,spd){ const e=new Enemy(sx,sy,vx,vy,type,hp,spd); if(type==='shield') e.hp=2; GAME.arrays.enemies.push(e); }
function spawnFromPerimeter(){
  const W=canvas.width, H=canvas.height;
  const cx=CORE.x, cy=CORE.y;
  const R = Math.max(W,H)*0.6 + 60*DPR; // spawn radius
  const ang = GAME.rng()*TAU;
  const sx=cx+Math.cos(ang)*R, sy=cy+Math.sin(ang)*R;

  const type=randomEnemyType();
  const speed=lerp(GAME.director.sMin, GAME.director.sMax, GAME.rng()); // random speeds per enemy
  const dx=cx-sx, dy=cy-sy; const len=Math.hypot(dx,dy)||1;
  const vx=dx/len*speed, vy=dy/len*speed;
  const hp=(type==='shield')?2:1;
  spawnEnemy(sx,sy,vx,vy,type,hp,speed);
}
function updateDirector(dt){
  const d=GAME.director; d.t+=dt; d.spawnT+=dt;

  // difficulty pacing: speed window & spawn cadence scale with wave and performance
  const perf = clamp((GAME.kills/ (10+GAME.wave*10)) + (CORE.integrity-1)*0.25, 0, 3);
  const baseEvery = 1.0 / (1 + perf*0.12 + (GAME.wave-1)*0.05);
  d.every = clamp(baseEvery, 0.28, 1.2);

  const baseMin = 80 + GAME.wave*3, baseMax = 160 + GAME.wave*7;
  d.sMin = clamp(baseMin, 70, 280);
  d.sMax = clamp(baseMax, 120, 480);

  const delay = d.every * (GAME.focusActive?1.7:1);
  if(d.spawnT>=delay){
    d.spawnT=0;
    const burst = (GAME.rng()<0.23);
    const count = burst ? (2 + (GAME.rng()*3|0)) : 1;
    for(let i=0;i<count;i++) spawnFromPerimeter();
  }

  // periodic wave bump
  if(GAME.t >= 24 + (GAME.wave-1)*8){
    GAME.wave++; GAME.t=0; GAME.score += 120 + GAME.wave*30;
  }
}

/* ---------- Weapons control ---------- */
const WEAPON_INFO={
  pulse:{name:'Pulse Bomb', desc:'Massive explosion at cursor; resonates. Click again near a bomb to detonate early.'},
  nova:{name:'Nova Ring', desc:'Expanding shockwave ring that damages on contact.'},
  rail:{name:'Rail Lance', desc:'Piercing beam from Core toward cursor (dual rails at higher Tech).'},
  net:{name:'Lockdown Net', desc:'Expanding lattice that slows; briefly roots near center at high Tech.'},
  singularity:{name:'Singularity', desc:'Temporary gravity well culminating in a huge blast.'},
};
function weaponUnlocked(id){ return GAME.weapons.unlocked.has(id); }
function cycleWeapon(dir){
  const order=GAME.weapons.order;
  let idx = order.indexOf(GAME.weapons.active);
  for(let i=1;i<=order.length;i++){
    let j = (idx + dir*i + order.length) % order.length;
    if(weaponUnlocked(order[j])){ GAME.weapons.active=order[j]; break; }
  }
  renderLegend();
}
function selectWeapon(n){ const id=GAME.weapons.order[n-1]; if(id && weaponUnlocked(id)){ GAME.weapons.active=id; renderLegend(); } }

function fireActive(x,y){
  if(GAME.state!=='play') return;
  const id=GAME.weapons.active;
  if(GAME.weapons.cd[id]>0) return;
  switch(id){
    case 'pulse': {
      const b=new Bomb(CORE.x,CORE.y,x,y); GAME.arrays.bombs.push(b);
      break;
    }
    case 'nova': {
      GAME.arrays.waves.push(new ShockWave(x,y));
      break;
    }
    case 'rail': {
      // primary beam
      fireRailAt(x,y,0);
      // dual rails at high Tech (slight angular spread)
      if(GAME.tech.flags.railDual){
        fireRailAt(x,y, 0.05);
        fireRailAt(x,y,-0.05);
      }
      cameraShake(5);
      break;
    }
    case 'net': {
      GAME.arrays.nets.push(new NetField(x,y));
      break;
    }
    case 'singularity': {
      GAME.arrays.wells.push(new Well(x,y));
      cameraShake(6);
      break;
    }
  }
  setCooldown(id);
}
function fireRailAt(x,y, spreadRad){
  const dx=x-CORE.x, dy=y-CORE.y; const len=Math.hypot(dx,dy)||1;
  let ang=Math.atan2(dy,dx)+spreadRad;
  const nx=Math.cos(ang), ny=Math.sin(ang);
  const L = Math.max(canvas.width, canvas.height);
  const x1=CORE.x+nx*(CORE.r), y1=CORE.y+ny*(CORE.r);
  const x2=CORE.x+nx*L, y2=CORE.y+ny*L;
  GAME.arrays.beams.push(new RailBeam(x1,y1,x2,y2));
}

function detonateNearestBomb(){
  let best=null, bestD=1e9;
  for(const b of GAME.arrays.bombs){ if(!b.alive) continue; const d=dist2(b.x,b.y,mouse.x,mouse.y); if(d<bestD){bestD=d; best=b;} }
  if(best){ best.explode(); }
}

/* ---------- Overclock ---------- */
function tryOverclock(){
  if(GAME.state!=='play') return;
  if(GAME.focus>=50 && !GAME.focusActive){ GAME.focusActive=true; }
}

/* ---------- Menu ---------- */
const overlay=$('#overlay'), menuBtn=$('#menuBtn');
menuBtn.onclick=()=>toggleMenu();
$('#playBtn').onclick=()=>{ resetGame('endless-'+Date.now()); SAVE.stats.games++; saveAll(); toggleMenu(false); };
$('#howBtn').onclick=()=>{};
$('#setBtn').onclick=()=>{};
$('#resetBtn').onclick=()=>{ if(confirm('Reset all progress?')){ localStorage.removeItem(SAVE_KEY); location.reload(); } };

function toggleMenu(force){
  const show = force ?? !overlay.classList.contains('show');
  overlay.classList.toggle('show', show);
  GAME.state = show ? (GAME.state==='play'?'pause':'menu') : 'play';
  if(show){ renderSettings(); renderStats(); }
}

/* ---------- Save ---------- */
function saveAll(){ localStorage.setItem(SAVE_KEY, JSON.stringify(SAVE)); }

/* ---------- HUD ---------- */
function updateHUD(){
  scoreEl.textContent=GAME.score|0;
  waveEl.textContent=GAME.wave|0;
  killsEl.textContent=GAME.kills|0;
  techEl.textContent=GAME.tech.level|0;
  bestEl.textContent=SAVE.stats.best|0;
  focusFill.style.width = `${(GAME.focus/GAME.focusMax)*100}%`;
  hpEl.textContent = '▣'.repeat(CORE.integrity) + '□'.repeat(3-CORE.integrity);
}
function renderLegend(){
  const order=GAME.weapons.order;
  legendEl.innerHTML = order.map((id,i)=>{
    const unlocked = weaponUnlocked(id);
    const cd = cooldownFor(id);
    const cls = `row ${!unlocked?'locked':''} ${GAME.weapons.active===id?'active':''}`;
    const key = i<5 ? (i+1) : '';
    const name = WEAPON_INFO[id].name;
    const desc = WEAPON_INFO[id].desc;
    const cdTxt = `CD ${cd.toFixed(2)}s`;
    const lockNote = (!unlocked) ? ` · Unlocks @ ${UNLOCKS.find(u=>u.id===id).kills} kills` : '';
    return `<div class="${cls}"><span class="key">[${key||'Q/E'}]</span> <b>${name}</b> — <span class="muted">${desc} · ${cdTxt}${lockNote}</span></div>`;
  }).join('');
}

/* ---------- Game Lifecycle ---------- */
function resetGame(seed){
  GAME.state='play'; overlay.classList.remove('show');
  GAME.rng=mulberry32(strToSeed(seed||'endless')); GAME.seed=seed;
  for(const k in GAME.arrays){ if(Array.isArray(GAME.arrays[k])) GAME.arrays[k].length=0; }
  GAME.t=0; GAME.last=performance.now();
  GAME.score=0; GAME.wave=1; GAME.kills=0; CORE.integrity=3;
  GAME.focus=0; GAME.focusActive=false;
  GAME.weapons.unlocked = new Set(['pulse']); GAME.weapons.active='pulse'; GAME.weapons.cd={pulse:0,nova:0,rail:0,net:0,singularity:0};
  recomputeTech();
  renderLegend(); updateHUD(); resize();
}

/* ---------- Main Loop ---------- */
function step(){
  const now=performance.now(); let dt=(now-GAME.last)/1000; GAME.last=now;
  dt=Math.min(dt, 0.035);
  if(GAME.focusActive){
    dt*=0.35;
    GAME.focus=Math.max(0, GAME.focus-40*dt);
    if(GAME.focus<=0) GAME.focusActive=false;
  }
  if(GAME.state==='play'){
    update(dt); render(dt);
  }else{
    render(0);
  }
  requestAnimationFrame(step);
}

function update(dt){
  GAME.t+=dt;
  // cooldowns
  for(const id of Object.keys(GAME.weapons.cd)){ GAME.weapons.cd[id]=Math.max(0, GAME.weapons.cd[id]-dt); }

  // bombs
  for(let i=GAME.arrays.bombs.length-1;i>=0;i--){ const b=GAME.arrays.bombs[i]; if(!b.alive){ GAME.arrays.bombs.splice(i,1); continue; } b.update(dt); }
  // explosions
  for(let i=GAME.arrays.explosions.length-1;i>=0;i--){ const e=GAME.arrays.explosions[i]; if(!e.alive){ GAME.arrays.explosions.splice(i,1); continue; } e.update(dt); }
  // beams
  for(let i=GAME.arrays.beams.length-1;i>=0;i--){ const b=GAME.arrays.beams[i]; if(!b.alive){ GAME.arrays.beams.splice(i,1); continue; } b.update(dt); }
  // nets
  for(let i=GAME.arrays.nets.length-1;i>=0;i--){ const n=GAME.arrays.nets[i]; if(!n.alive){ GAME.arrays.nets.splice(i,1); continue; } n.update(dt); }
  // wells
  for(let i=GAME.arrays.wells.length-1;i>=0;i--){ const w=GAME.arrays.wells[i]; if(!w.alive){ GAME.arrays.wells.splice(i,1); continue; } w.update(dt); }
  // nova shockwaves
  for(let i=GAME.arrays.waves.length-1;i>=0;i--){ const wv=GAME.arrays.waves[i]; if(!wv.alive){ GAME.arrays.waves.splice(i,1); continue; } wv.update(dt); }

  // enemies
  for(let i=GAME.arrays.enemies.length-1;i>=0;i--){
    const e=GAME.arrays.enemies[i]; if(!e.alive){ GAME.arrays.enemies.splice(i,1); continue; } e.update(dt);
  }

  // particles
  for(let i=GAME.arrays.particles.length-1;i>=0;i--){
    const p=GAME.arrays.particles[i]; p.t+=dt; if(p.t>p.life){ GAME.arrays.particles.splice(i,1); continue; }
    p.x+=p.vx*dt; p.y+=p.vy*dt; p.vx *= (1-1.6*dt); p.vy *= (1-1.6*dt); p.vy += 12*dt;
  }
  // flashes
  for(let i=GAME.arrays.flashes.length-1;i>=0;i--){
    const r=GAME.arrays.flashes[i]; r.t+=dt; if(r.t>r.life){ GAME.arrays.flashes.splice(i,1); continue; }
  }
  // resonances
  for(let i=GAME.arrays.resonances.length-1;i>=0;i--){
    const f=GAME.arrays.resonances[i]; f.t+=dt; if(f.t>f.life){ GAME.arrays.resonances.splice(i,1); continue; }
  }

  // blast damage (for explosions only; waves/beams/nets apply internally)
  handleBlastDamage();

  // spawn & wave pacing
  updateDirector(dt);

  // Overclock trickle
  GAME.focus = clamp(GAME.focus + 6*dt, 0, GAME.focusMax);

  // end?
  if(CORE.integrity<=0){ endGame(); return; }

  updateHUD();
}

function handleBlastDamage(){
  let killsFrame=0;
  for(const ex of GAME.arrays.explosions){
    if(!ex.alive) continue;
    const R=ex.r;
    for(const en of GAME.arrays.enemies){
      if(!en.alive) continue;
      if(dist2(ex.x,ex.y,en.x,en.y) <= (R+en.r)*(R+en.r)){ en.hit(2); if(!en.alive){ killsFrame++; GAME.focus=clamp(GAME.focus+6,0,GAME.focusMax); } }
    }
  }
  if(killsFrame>0){ GAME.score += killsFrame*15; }
}

/* ---------- Rendering ---------- */
function render(dt){
  const W=canvas.width, H=canvas.height;
  // camera shake
  if(GAME.camera.shake>0) GAME.camera.shake*=0.9; else GAME.camera.shake=0;
  const sx=(GAME.rng()*2-1)*GAME.camera.shake, sy=(GAME.rng()*2-1)*GAME.camera.shake;
  ctx.setTransform(1,0,0,1, sx, sy);

  ctx.clearRect(-10,-10,W+20,H+20);
  // starfield
  for(let i=0;i<40;i++){
    const px=(i*97 % W), py=(i*71 % H);
    ctx.fillStyle=`rgba(255,255,255,${0.03 + (i%5)*0.01})`;
    ctx.fillRect(px,py,2*DPR,2*DPR);
  }
  // orbital grid
  ctx.save(); ctx.globalAlpha=0.35;
  ctx.strokeStyle='rgba(100,210,255,.25)'; ctx.lineWidth=1*DPR;
  for(let r=CORE.r*2; r<=Math.max(W,H)*0.6; r+=80*DPR){ ctx.beginPath(); ctx.arc(CORE.x,CORE.y,r,0,TAU); ctx.stroke(); }
  ctx.restore();

  // resonance rings
  for(const f of GAME.arrays.resonances){
    const a=1-(f.t/f.life);
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.lineWidth=1.4*DPR; ctx.strokeStyle=`rgba(100,210,255,${.18*a})`;
    ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,TAU); ctx.stroke(); ctx.restore();
  }

  // bombs
  for(const b of GAME.arrays.bombs){ b.draw(); }
  // nets
  for(const n of GAME.arrays.nets){ n.draw(); }
  // wells
  for(const w of GAME.arrays.wells){ w.draw(); }
  // explosions
  for(const e of GAME.arrays.explosions){ e.draw(); }
  // beams
  for(const b of GAME.arrays.beams){ b.draw(); }
  // nova waves
  for(const w of GAME.arrays.waves){ w.draw(); }

  // enemies
  for(const e of GAME.arrays.enemies){ e.draw(); }

  // particles
  for(const p of GAME.arrays.particles){
    const a=1-(p.t/p.life);
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.fillStyle=(p.mode==='kill')?`rgba(255,98,162,${.65*a})`:`rgba(100,210,255,${.6*a})`;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,TAU); ctx.fill(); ctx.restore();
  }

  // flashes
  for(const r of GAME.arrays.flashes){
    const a=1-(r.t/r.life);
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.lineWidth=2*DPR; ctx.strokeStyle=`rgba(255,255,255,${.25*a})`;
    ctx.beginPath(); ctx.arc(r.x,r.y,r.r,0,TAU); ctx.stroke(); ctx.restore();
  }

  // Core
  ctx.save(); ctx.globalCompositeOperation='lighter';
  ctx.fillStyle='rgba(60,255,158,.9)'; ctx.shadowBlur=18; ctx.shadowColor='rgba(60,255,158,.85)';
  ctx.beginPath(); ctx.arc(CORE.x,CORE.y, CORE.r, 0, TAU); ctx.fill();
  ctx.restore();

  // Aim reticle
  ctx.save(); ctx.globalCompositeOperation='lighter';
  const rr=10*DPR + Math.sin(GAME.t*7)*1.2*DPR;
  ctx.strokeStyle='rgba(100,210,255,.55)'; ctx.lineWidth=1.2*DPR;
  ctx.beginPath(); ctx.arc(mouse.x,mouse.y,rr,0,TAU); ctx.stroke();
  ctx.restore();
}

/* ---------- Explosion spawner with chain logic ---------- */
function spawnExplosion(x,y,checkRes=true){
  let boost=0;
  if(checkRes){
    for(const f of GAME.arrays.resonances){
      if(dist2(x,y,f.x,f.y) <= f.r*f.r) boost++;
    }
  }
  GAME.arrays.explosions.push(new Explosion(x,y, boost));
  cameraShake(5 + boost*2);
}

/* ---------- Game Over ---------- */
function endGame(){
  GAME.state='over';
  SAVE.stats.best = Math.max(SAVE.stats.best|0, GAME.score|0);
  SAVE.stats.totalScore += GAME.score|0;
  saveAll();
  setTimeout(()=>{ toggleMenu(true); alert('Core destroyed.\nScore: '+GAME.score); }, 100);
}

/* ---------- Boot ---------- */
applyPalette(); resize(); renderSettings(); renderStats(); renderLegend();
toggleMenu(true);
requestAnimationFrame(step);

/* ---------- Extra: detonate nearest bomb on 2nd click ---------- */
addEventListener('mousedown', e=>{
  if(e.button===0 && GAME.state==='play' && GAME.weapons.active==='pulse'){
    let nearest=null, best=1e9;
    for(const b of GAME.arrays.bombs){ if(!b.alive) continue; const d=dist2(b.x,b.y,mouse.x,mouse.y); if(d<best){best=d; nearest=b;} }
    if(nearest && Math.sqrt(best)<=32*DPR){ nearest.explode(); }
  }
}, {passive:true});
</script>
</body>
</html>

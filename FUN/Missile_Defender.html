<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>QUANTUM DEFENSE — Neon Missile Commandlike</title>
<style>
  :root{
    --bg:#0a0f1f;--bg2:#0c1228;--ink:#e6ecff;--ink-dim:#97a0b8;
    --accent:#5fd2ff;--accent2:#9b5cff;--good:#3cff9e;--bad:#ff5f7a;--warn:#ffc658;
    --glass: rgba(255,255,255,.06); --glass-strong: rgba(255,255,255,.12);
    --shadow: 0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background: radial-gradient(1200px 800px at 70% 10%, var(--bg2), var(--bg)); color:var(--ink); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";}
  #wrap{position:fixed; inset:0; display:grid; grid-template-rows:auto 1fr}
  header{height:48px; display:flex; align-items:center; justify-content:space-between; padding:8px 12px; color:var(--ink-dim); user-select:none}
  header .brand{letter-spacing:.18em; font-weight:700; color:var(--ink); font-size:14px}
  header .brand b{color:var(--accent)}
  header .btn{border:1px solid var(--glass-strong); border-radius:10px; padding:6px 10px; background:var(--glass); color:var(--ink); cursor:pointer; transition:.2s; backdrop-filter: blur(6px);}
  header .btn:hover{transform:translateY(-1px); box-shadow:0 2px 16px rgba(95,210,255,.25)}
  #game{width:100%; height:100%; display:block; background:transparent;}
  #hud{position:fixed; inset:48px 0 0 0; pointer-events:none; font-size:12px}
  #hud .top{position:absolute; top:8px; left:12px; display:flex; gap:12px; align-items:center}
  #hud .top .pill{pointer-events:auto; padding:6px 10px; border-radius:999px; background:var(--glass); border:1px solid var(--glass-strong); backdrop-filter: blur(4px);}
  .meter{position:relative; width:160px; height:10px; border-radius:6px; background:rgba(255,255,255,.08); overflow:hidden; border:1px solid rgba(255,255,255,.1)}
  .meter .fill{position:absolute; inset:0; width:0%; background:linear-gradient(90deg,var(--accent),var(--accent2)); box-shadow:0 0 12px rgba(95,210,255,.6) inset}
  .meter.small{width:110px}
  .legend{opacity:.8; margin-left:6px}
  #hud .score{font-weight:700; letter-spacing:.06em}
  #hud .right{position:absolute; top:8px; right:12px; display:flex; gap:8px}
  #hud .combo{position:absolute; left:50%; transform:translate(-50%,0); top:16px; font-weight:800; letter-spacing:.1em; text-shadow:0 0 12px rgba(159,92,255,.6)}
  #hud .bottom{position:absolute; bottom:16px; left:12px; display:flex; gap:12px; align-items:center}
  #hud .city{width:10px; height:10px; border-radius:50%; background:var(--good); box-shadow:0 0 12px rgba(60,255,158,.8)}
  #hud .city.dead{background:var(--bad); box-shadow:none; opacity:.5}
  #hud .tip{position:absolute; bottom:16px; right:12px; opacity:.7}
  /* Menus */
  #overlay{position:fixed; inset:48px 0 0 0; display:none; align-items:center; justify-content:center; background:linear-gradient(180deg, rgba(10,15,31,.0), rgba(10,15,31,.45) 10%, rgba(10,15,31,.65)); backdrop-filter: blur(6px); }
  #overlay.show{display:flex}
  .panel{width:min(880px, calc(100% - 32px)); max-height:calc(100% - 64px); overflow:auto; background:var(--glass); border:1px solid var(--glass-strong); border-radius:18px; padding:18px; box-shadow: var(--shadow)}
  .grid{display:grid; grid-template-columns: 1fr 1fr; gap:18px}
  .big-title{font-size:22px; font-weight:900; letter-spacing:.16em; margin:6px 0 14px; color:var(--ink)}
  .subtitle{margin-top:8px; color:var(--ink-dim)}
  .btn-row{display:flex; gap:10px; flex-wrap:wrap}
  .cta{cursor:pointer; padding:12px 14px; border-radius:12px; border:1px solid var(--glass-strong); background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03)); transition:.15s}
  .cta.primary{background:linear-gradient(180deg, rgba(95,210,255,.22), rgba(95,210,255,.08)); border-color: rgba(95,210,255,.35); color:#07121d; font-weight:800}
  .cta.warn{background:linear-gradient(180deg, rgba(255,198,88,.22), rgba(255,198,88,.08)); border-color: rgba(255,198,88,.35)}
  .cta:hover{transform:translateY(-1px); box-shadow:0 6px 24px rgba(95,210,255,.2)}
  .section{padding:12px 0; border-top:1px dashed rgba(255,255,255,.12); margin-top:10px}
  .row{display:flex; gap:10px; align-items:center; justify-content:space-between; padding:8px 0; border-bottom:1px dashed rgba(255,255,255,.08)}
  .row:last-child{border-bottom:none}
  .row input[type="range"]{width:200px}
  .tag{padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.12); font-size:11px; letter-spacing:.08em}
  .muted{opacity:.7}
  .kbd{padding:3px 6px; border-radius:6px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06); font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px}
  .right-fixed{position:fixed; top:8px; right:12px}
  a.link{color:var(--accent)}
  @media (max-width:760px){ .grid{grid-template-columns:1fr} }
</style>
</head>
<body>
<div id="wrap">
  <header>
    <div class="brand">Q<u></u>DEF<b>∎</b> // QUANTUM DEFENSE</div>
    <div class="right-fixed">
      <button id="menuBtn" class="btn" title="Menu / Pause (Esc)">☰ Menu</button>
    </div>
  </header>
  <canvas id="game" aria-label="Quantum Defense playfield"></canvas>
  <div id="hud" aria-hidden="false">
    <div class="top">
      <div class="pill"><span class="legend">Score</span> · <span id="score" class="score">0</span></div>
      <div class="pill"><span class="legend">Wave</span> · <span id="wave">1</span></div>
      <div class="pill"><span class="legend">Ammo</span>
        <div class="meter small"><div id="ammoFill" class="fill"></div></div>
      </div>
      <div class="pill"><span class="legend">Heat</span>
        <div class="meter"><div id="heatFill" class="fill"></div></div>
      </div>
      <div class="pill"><span class="legend">Focus</span>
        <div class="meter small"><div id="focusFill" class="fill"></div></div>
      </div>
    </div>
    <div class="right">
      <div class="pill"><span class="legend">Best</span> · <span id="best">0</span></div>
      <div class="pill"><span class="legend">Daily</span> · <span id="dailyLabel">—</span></div>
    </div>
    <div class="combo" id="comboBanner"></div>
    <div class="bottom">
      <div id="city0" class="city"></div>
      <div id="city1" class="city"></div>
      <div id="city2" class="city"></div>
    </div>
    <div class="tip muted">Click to fire, click again to detonate early · <span class="kbd">A/D</span> move · <span class="kbd">Shift</span> Focus · <span class="kbd">Esc</span> Pause</div>
  </div>

  <!-- Overlay / Menu -->
  <div id="overlay" role="dialog" aria-modal="true">
    <div class="panel">
      <div class="big-title">QUANTUM DEFENSE</div>
      <div class="subtitle">Missile‑command DNA, reimagined: resonance chains, a pacing “Director”, daily seeds, and crunchy neon juice.</div>
      <div class="section">
        <div class="btn-row">
          <button class="cta primary" id="playBtn">▶ Play (Endless)</button>
          <button class="cta" id="dailyBtn">◆ Daily Challenge</button>
          <button class="cta" id="howBtn">? How to Play</button>
          <button class="cta" id="upgBtn">⬆ Upgrades</button>
          <button class="cta" id="achBtn">★ Achievements</button>
          <button class="cta" id="setBtn">⚙ Settings</button>
          <button class="cta warn" id="resetBtn" title="Reset all saved progress">⟲ Reset Save</button>
        </div>
      </div>

      <div id="menuContent" class="grid">
        <div class="section">
          <div class="big-title">Upgrades</div>
          <div id="upgrades"></div>
        </div>
        <div class="section">
          <div class="big-title">Settings</div>
          <div id="settings"></div>
          <div class="big-title" style="margin-top:16px">Stats</div>
          <div id="stats"></div>
        </div>
      </div>

      <div class="section">
        <div class="big-title">How to Play</div>
        <div class="subtitle">
          Defend the moving <b>Convoy</b> by intercepting threats. Every kill leaves a faint <b>Resonance Field</b> for 3s—detonate new explosions inside it to
          amplify <b>blast radius</b> and stack <b>Combo Multipliers</b>. Don’t overheat; conserve ammo; ride the flow.
        </div>
      </div>
      <div class="section muted" style="font-size:12px">
        <span class="tag">Photosensitivity</span> Contains flashes & screen shake (toggle in Settings).
        <span class="tag">Persistence</span> Uses localStorage for best score, upgrades & achievements.
        <span class="tag">Version</span> 1.0
      </div>
    </div>
  </div>
</div>

<script>
/* ============================================================
   QUANTUM DEFENSE • A neon, reimagined missile‑commandlike.
   Design goals:
     - Tight, deterministic core with variable-timestep safety.
     - Randomized enemy speeds & behaviors (per type + seeded RNG).
     - Blast radius math == visuals (no desync) + resonance chains.
     - Dynamic Difficulty Director: waves adjust spawn cadence
       & speed windows on performance (keeps a Flow‑like channel).
     - Daily challenge: seed from UTC date => fair replayability.
     - “Juice”: screenshake, hit‑stop, glow, particles, SFX.
   ============================================================ */

/* ================= Utility & RNG ================= */
const TAU = Math.PI*2;
const clamp = (v, a, b)=>Math.max(a, Math.min(b, v));
const lerp  = (a,b,t)=>a+(b-a)*t;
const easeOutQuad = t => 1-(1-t)*(1-t);
function hsl(h,s,l,a=1){return `hsla(${h},${s}%,${l}%,${a})`}

// Mulberry32 PRNG (deterministic, lightweight)
function mulberry32(seed){
  let t = seed>>>0;
  return function(){
    t += 0x6D2B79F5; t = Math.imul(t ^ (t>>>15), t|1);
    t ^= t + Math.imul(t ^ (t>>>7), t|61);
    return ((t ^ (t>>>14))>>>0) / 4294967296;
  }
}
function strToSeed(s){
  let h=2166136261>>>0;
  for(let i=0;i<s.length;i++){h ^= s.charCodeAt(i); h = Math.imul(h, 16777619);}
  return h>>>0;
}

/* ================= Save / Persistence ================= */
const SAVE_KEY = 'qdef_save_v1';
let SAVE = JSON.parse(localStorage.getItem(SAVE_KEY) || '{}');
if(!SAVE.upgrades){ SAVE.upgrades = { radius:0, reload:0, speed:0, focus:0 }; }
if(!SAVE.stats){ SAVE.stats = { games:0, best:0, totalScore:0, enemies:0, chains:0, dailies:0 }; }
if(!SAVE.settings){ SAVE.settings = { particles:true, shake:true, flashes:true, colorblind:false, volume:0.6, difficulty:'normal' }; }
if(!SAVE.ach){ SAVE.ach = { firstBlood:false, chain10:false, noOverheat:false, perfectWave:false }; }

/* ================= Canvas & Rendering ================= */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio||1));
function resize(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height= Math.floor(rect.height* DPR);
}
resize(); addEventListener('resize', resize);

/* ================= Audio (WebAudio) ================= */
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audio = new AudioCtx();
let masterGain = audio.createGain(); masterGain.gain.value = SAVE.settings.volume; masterGain.connect(audio.destination);
function sfx({type='sine', freq=440, dur=0.08, vol=0.2, attack=0.005, decay=0.05}){
  try{
    const t0 = audio.currentTime;
    const osc = audio.createOscillator(); osc.type = type;
    const gain= audio.createGain(); gain.gain.value = 0;
    osc.frequency.value=freq; osc.connect(gain).connect(masterGain); osc.start();
    gain.gain.linearRampToValueAtTime(vol, t0+attack);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0+attack+decay+dur);
    osc.stop(t0+attack+decay+dur+0.02);
  }catch(e){}
}
function clickSfx(){ sfx({type:'square', freq:540, vol:.15}); }
function boomSfx(){ sfx({type:'triangle', freq:110, vol:.25, dur:.12}); }
function killSfx(){ sfx({type:'sawtooth', freq:280, vol:.12, dur:.08}); }
function chainSfx(){ sfx({type:'sine', freq:700, vol:.2, dur:.2}); }

/* ================= UI Elements ================= */
const $ = s=>document.querySelector(s);
const scoreEl = $('#score'), waveEl = $('#wave'), bestEl = $('#best'),
      ammoFill = $('#ammoFill'), heatFill = $('#heatFill'), focusFill = $('#focusFill'),
      comboBanner = $('#comboBanner'), dailyLabel = $('#dailyLabel');
bestEl.textContent = SAVE.stats.best|0;

/* ================= Game State ================= */
const GAME = {
  state: 'menu', // 'menu'|'play'|'pause'|'over'
  width: ()=>canvas.width, height: ()=>canvas.height,
  rng: mulberry32(12345),
  seedStr: 'endless',
  time: 0, dt: 0, last: performance.now(),
  score:0, wave:1, combo:0, comboTimer:0, focus:0, focusMax:100, focusActive:false,
  ammo: 10, ammoMax:10, ammoReload: 1.6, ammoTimer:0,
  heat:0, heatMax:100, overheated:false, cities:[true,true,true],
  statsWavePerfect:true,
  daily:false,
  enemies:[], shots:[], explosions:[], particles:[], resonances:[],
  convoy:{ x:0, speed:60 },
  director:{ t:0, spawnT:0, spawnEvery:1.2, speedMin:60, speedMax:140, intensity:0 },
};
function resetGame(seedStr, daily=false){
  GAME.seedStr = seedStr; GAME.rng = mulberry32(strToSeed(seedStr));
  GAME.time=0; GAME.last=performance.now();
  GAME.score=0; GAME.wave=1; GAME.combo=0; GAME.comboTimer=0;
  GAME.focus=0; GAME.focusActive=false; GAME.ammo=10 + SAVE.upgrades.reload*1; GAME.ammoMax=GAME.ammo;
  GAME.heat=0; GAME.overheated=false; GAME.cities=[true,true,true];
  GAME.statsWavePerfect=true; GAME.daily = daily;
  GAME.enemies.length = GAME.shots.length = GAME.explosions.length = GAME.particles.length = GAME.resonances.length = 0;
  GAME.convoy.x = GAME.width()/2; GAME.convoy.speed = 60;
  GAME.director = { t:0, spawnT:0, spawnEvery:1.2, speedMin:60, speedMax:140, intensity:0 };
}

/* ================= Inputs ================= */
let mouse = {x:0, y:0, down:false};
canvas.addEventListener('mousemove', e=>{
  const b = canvas.getBoundingClientRect(); mouse.x=(e.clientX - b.left)*DPR; mouse.y=(e.clientY - b.top)*DPR;
},{passive:true});
canvas.addEventListener('mousedown', (e)=>{ e.preventDefault(); resumeAudio(); mouse.down=true; fire(); }, {passive:false});
addEventListener('mouseup', ()=>{mouse.down=false});
addEventListener('contextmenu', e=>{ e.preventDefault(); detonateNearest(); });
let keys = {};
addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true;
  if(e.key==='Escape'){ toggleMenu(); }
  if(e.key==='Shift'){ tryFocus(); }
});
addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

function resumeAudio(){ if(audio.state==='suspended') audio.resume(); }

/* ================= Entities ================= */
class Shot{
  constructor(x,y,tx,ty){
    this.x=x; this.y=y; this.tx=tx; this.ty=ty;
    const dx=tx-x, dy=ty-y; const len=Math.hypot(dx,dy)||1;
    const spd = 260 + SAVE.upgrades.speed*26;
    this.vx=dx/len*spd; this.vy=dy/len*spd;
    this.radius=2; this.alive=true; this.age=0; this.maxAge=6;
  }
  update(dt){
    this.age+=dt; if(this.age>this.maxAge) this.alive=false;
    this.x += this.vx*dt; this.y += this.vy*dt;
    // auto detonate if close to target:
    const d2 = (this.x-this.tx)**2 + (this.y-this.ty)**2;
    if(d2 < 16*16) this.explode();
  }
  draw(){
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.shadowBlur=18; ctx.shadowColor='rgba(95,210,255,.8)';
    ctx.fillStyle='rgba(95,210,255,.9)';
    ctx.beginPath(); ctx.arc(this.x,this.y,this.radius,0,TAU); ctx.fill();
    ctx.restore();
    // trailing line
    ctx.strokeStyle='rgba(159,92,255,.35)';
    ctx.lineWidth=1*DPR; ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(this.x-this.vx*.06,this.y-this.vy*.06); ctx.stroke();
  }
  explode(){
    if(!this.alive) return;
    this.alive=false; spawnExplosion(this.x,this.y,false);
  }
}

class Explosion{
  constructor(x,y,chainBoost=0){
    this.x=x; this.y=y; this.t=0; this.life=0.55; // seconds
    const base = 46 + SAVE.upgrades.radius*6; // base radius
    const chain = base * (1 + 0.18*(chainBoost)); // chain amplifies
    this.rMax = clamp(chain, base, base*2.2);
    this.r = 1; this.alive=true;
  }
  update(dt){
    this.t += dt; const p = clamp(this.t/this.life, 0, 1);
    // growth then fade
    this.r = this.rMax * easeOutQuad( clamp(p*1.35,0,1) );
    if(this.t>this.life) this.alive=false;
    // Create/extend resonance on peak
    if(Math.abs(this.r - this.rMax) < 0.5 && this.t < this.life*0.8){
      spawnResonance(this.x,this.y, this.rMax*0.8);
    }
  }
  draw(){
    // shock ring
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    const alpha = 1 - (this.t/this.life);
    const grad = ctx.createRadialGradient(this.x,this.y, this.r*0.2, this.x,this.y, this.r);
    grad.addColorStop(0, `rgba(159,92,255,${.22*alpha})`);
    grad.addColorStop(0.6, `rgba(95,210,255,${.16*alpha})`);
    grad.addColorStop(1, `rgba(95,210,255,0)`);
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,TAU); ctx.fill();
    ctx.restore();
  }
}

class Enemy{
  constructor(x, y, vx, vy, type='meteor', hp=1, speed=100){
    this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.type=type; this.hp=hp; this.baseSpeed=speed;
    this.r = (type==='meteor'?6: type==='splitter'?5: type==='dasher'?6: type==='shield'?7:6) * DPR;
    this.alive=true; this.age=0;
  }
  update(dt){
    this.age+=dt;
    // type behaviors
    if(this.type==='dasher'){
      // accelerates near bottom
      const h = GAME.height();
      const mult = (this.y > h*0.6) ? 1.6 : 1.0;
      this.x += this.vx*dt*mult; this.y += this.vy*dt*mult;
    }else if(this.type==='splitter'){
      this.x += this.vx*dt; this.y += this.vy*dt;
      // subtle wobble
      this.x += Math.sin(this.age*6)*8*dt;
    }else if(this.type==='shield'){
      this.x += this.vx*dt; this.y += this.vy*dt;
    }else{
      // meteor default
      this.x += this.vx*dt; this.y += this.vy*dt;
    }

    // hit convoy?
    if(this.y >= GAME.height()-30*DPR){
      damageCityNear(this.x);
      this.alive=false;
      cameraShake(8);
    }
  }
  hit(){
    this.hp--;
    if(this.hp<=0){
      this.kill();
    }else{
      // shield pop feedback
      particleBurst(this.x,this.y, 6, 'shield');
    }
  }
  kill(){
    if(!this.alive) return;
    this.alive=false; GAME.score += 5;
    SAVE.stats.enemies++;
    particleBurst(this.x,this.y, 9, 'kill');
    killSfx();
    // Splitter splits
    if(this.type==='splitter'){
      const n=3;
      for(let i=0;i<n;i++){
        const ang = -Math.PI/2 + (i-1)*0.35;
        const spd = (this.baseSpeed*0.7) * (0.9 + GAME.rng()*0.2);
        spawnEnemy(this.x, this.y, Math.cos(ang)*spd*0.6, Math.sin(ang)*spd, 'meteor', 1, spd);
      }
    }
  }
  draw(){
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.shadowBlur=12; ctx.shadowColor='rgba(255,98,162,.75)';
    ctx.fillStyle=(this.type==='shield')?'rgba(255,198,88,.9)':'rgba(255,98,162,.9)';
    ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,TAU); ctx.fill();
    // highlight
    ctx.shadowBlur=0; ctx.fillStyle='rgba(255,255,255,.6)'; ctx.beginPath(); ctx.arc(this.x-2*DPR,this.y-1*DPR,this.r*0.35,0,TAU); ctx.fill();
    ctx.restore();
  }
}

/* ================= Effects ================= */
let CAMERA = {x:0, y:0, shake:0};
function cameraShake(strength){
  if(!SAVE.settings.shake) return;
  CAMERA.shake = Math.max(CAMERA.shake, strength);
}
function particleBurst(x,y, n, mode='kill'){
  if(!SAVE.settings.particles) return;
  for(let i=0;i<n;i++){
    const a = GAME.rng()*TAU;
    const sp = (mode==='kill'? (40+GAME.rng()*80) : 30+GAME.rng()*50);
    GAME.particles.push({
      x,y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, t:0, life:.8, size: (mode==='kill'? 2:1.5)*DPR, mode
    });
  }
}
function spawnResonance(x,y,r){
  // faint field that boosts next explosion radius if detonated within
  GAME.resonances.push({x,y,r, t:0, life:3});
}
function drawResonances(dt){
  for(let i=GAME.resonances.length-1;i>=0;i--){
    const f = GAME.resonances[i];
    f.t+=dt; if(f.t>f.life){ GAME.resonances.splice(i,1); continue; }
    const a = 1 - (f.t/f.life);
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.lineWidth=1.2*DPR; ctx.strokeStyle=`rgba(95,210,255,${.18*a})`;
    ctx.beginPath(); ctx.arc(f.x,f.y,f.r,0,TAU); ctx.stroke(); ctx.restore();
  }
}

/* ================= Convoy (Cities) ================= */
function drawConvoy(dt){
  const y = GAME.height()-20*DPR;
  // oscillate convoy horizontally
  GAME.convoy.x += GAME.convoy.speed*dt*(keys['d']||keys['arrowright']?1:(keys['a']||keys['arrowleft']?-1:0));
  GAME.convoy.x = clamp(GAME.convoy.x, 40*DPR, GAME.width()-40*DPR);

  // draw three "cores" moving with slight phase offsets
  const offsets = [-50, 0, 50].map(o=>o*DPR);
  for(let i=0;i<3;i++){
    const alive = GAME.cities[i];
    const x = GAME.convoy.x + offsets[i];
    ctx.save();
    ctx.globalCompositeOperation='lighter';
    ctx.shadowBlur=alive?18:0;
    ctx.shadowColor= alive? 'rgba(60,255,158,.9)':'transparent';
    ctx.fillStyle= alive? 'rgba(60,255,158,.9)' : 'rgba(255,95,122,.55)';
    ctx.beginPath(); ctx.arc(x,y, 7*DPR, 0, TAU); ctx.fill();
    ctx.restore();
    // HUD sync
    const el = document.getElementById('city'+i);
    el.classList.toggle('dead', !alive);
  }
}
function aliveCities(){ return GAME.cities.filter(Boolean).length; }
function damageCityNear(x){
  // pick nearest alive city to x
  let idx=0, best=Infinity;
  const offsets = [-50,0,50].map(o=>o*DPR);
  for(let i=0;i<3;i++){
    if(!GAME.cities[i]) continue;
    const cx = GAME.convoy.x + offsets[i];
    const d = Math.abs(x - cx);
    if(d<best){best=d; idx=i;}
  }
  GAME.cities[idx] = false;
}

/* ================= Spawning & Director ================= */
function randomEnemyType(){
  const r = GAME.rng();
  if(r<0.62) return 'meteor';
  if(r<0.78) return 'splitter';
  if(r<0.92) return 'dasher';
  return 'shield';
}
function spawnEnemy(sx,sy,vx,vy,type,hp,spd){
  const e = new Enemy(sx,sy,vx,vy,type,hp,spd);
  if(type==='shield') e.hp = 2;
  GAME.enemies.push(e);
}
function spawnWavePiece(){
  const W = GAME.width(), H = GAME.height();
  const type = randomEnemyType();
  // speeds randomized per spawn (uniform within [speedMin, speedMax])
  const speed = lerp(GAME.director.speedMin, GAME.director.speedMax, GAME.rng());
  const sx = GAME.rng()*W, sy = -10*DPR;

  // pick target around convoy zone with slight noise
  const convoyX = GAME.convoy.x + (GAME.rng()*80-40);
  const tx = clamp(convoyX, 20*DPR, W-20*DPR);
  const ty = H - 20*DPR;

  const dx=tx-sx, dy=ty-sy; const len=Math.hypot(dx,dy)||1;
  const vx=dx/len*speed, vy=dy/len*speed;

  const hp = (type==='shield')?2:1;
  spawnEnemy(sx,sy,vx,vy, type, hp, speed);
}
function updateDirector(dt){
  const d = GAME.director;
  d.t += dt; d.spawnT += dt;

  // Basic DDA: adjust spawn cadence & speed band around recent performance
  // If player is acing (combo high, cities alive), tighten spawnEvery; else loosen.
  const perf = clamp((GAME.combo*0.05) + (aliveCities()-1), 0, 3);
  const baseEvery = 1.2 / (1 + perf*0.12 + (GAME.wave-1)*0.06);
  d.spawnEvery = clamp(baseEvery, 0.35, 1.2);

  // Gradually expand speed window per wave (still random per enemy)
  const baseMin = 60 + GAME.wave*3, baseMax = 140 + GAME.wave*6;
  d.speedMin = clamp(baseMin, 60, 260);
  d.speedMax = clamp(baseMax, 110, 420);

  // spawn logic (throttle when focus is active to preserve fairness)
  const spawnDelay = d.spawnEvery * (GAME.focusActive?1.6:1);
  if(d.spawnT >= spawnDelay){
    d.spawnT = 0;
    // spawn burst or singles
    const burst = (GAME.rng()<0.2);
    const count = burst ? (2 + (GAME.rng()*3|0)) : 1;
    for(let i=0;i<count;i++) spawnWavePiece();
  }
}

/* ================= Player Actions ================= */
const turret = { x: ()=>GAME.convoy.x, y: ()=>GAME.height()-20*DPR };
function fire(){
  if(GAME.state!=='play') return;
  if(GAME.overheated) return;
  if(GAME.ammo<=0) return;

  // heat and ammo
  GAME.ammo--; GAME.heat += 8; if(GAME.heat>=GAME.heatMax){ GAME.overheated=true; }

  const x = turret.x(), y = turret.y();
  GAME.shots.push( new Shot(x,y, mouse.x, mouse.y) );
  clickSfx();
}
function detonateNearest(){
  // Find nearest in-flight shot and detonate
  let best=null, bestD=1e9;
  for(const s of GAME.shots){
    if(!s.alive) continue;
    const d2=(s.x-mouse.x)**2 + (s.y-mouse.y)**2;
    if(d2<bestD){ bestD=d2; best=s; }
  }
  if(best){ best.explode(); }
}
function tryFocus(){
  if(GAME.state!=='play') return;
  if(GAME.focus>=GAME.focusMax*0.5 && !GAME.focusActive){
    GAME.focusActive=true;
    sfx({type:'sine', freq:360, vol:.2, dur:.3});
  }
}

/* ================= Explosions & Damage ================= */
function spawnExplosion(x,y, chainFromResonance=true){
  // chain bonus if inside resonance
  let boost = 0;
  if(chainFromResonance){
    for(const f of GAME.resonances){
      const d2=(x-f.x)**2+(y-f.y)**2; if(d2<=f.r*f.r){ boost++; }
    }
  }
  GAME.explosions.push( new Explosion(x,y, boost + Math.floor(GAME.combo/5)) );
  cameraShake(4 + boost*2);
  boomSfx();
  // scoring / combo
  if(GAME.comboTimer<=0) GAME.combo=0; // restart window if it had lapsed
  GAME.comboTimer = 1.2; // seconds to sustain combo chain
}

function handleBlastDamage(){
  // exact circle vs circle test; visuals == logic:
  // enemy dies if center within (explosion.r + enemy.r)
  let killsThisFrame = 0;
  for(const ex of GAME.explosions){
    if(!ex.alive) continue;
    const R = ex.r;
    for(const en of GAME.enemies){
      if(!en.alive) continue;
      const dx=en.x-ex.x, dy=en.y-ex.y;
      if(dx*dx + dy*dy <= (R+en.r)**2){
        en.hit();
        if(!en.alive) { killsThisFrame++; GAME.focus = clamp(GAME.focus + 4 + GAME.combo, 0, GAME.focusMax); }
      }
    }
  }
  if(killsThisFrame>0){
    GAME.combo += killsThisFrame;
    GAME.score += killsThisFrame * (10 + Math.min(100, GAME.combo*2));
    comboFlash(GAME.combo);
    if(killsThisFrame>=3) chainSfx();
  }
}

/* ================= HUD ================= */
function comboFlash(n){
  comboBanner.textContent = n>=2 ? `CHAIN ×${n}` : '';
  comboBanner.style.opacity = n>=2 ? '1' : '0';
  if(n>=2){ setTimeout(()=> comboBanner.style.opacity='0', 600); }
}
function updateHud(){
  scoreEl.textContent = GAME.score|0;
  waveEl.textContent = GAME.wave|0;
  bestEl.textContent = SAVE.stats.best|0;
  dailyLabel.textContent = GAME.daily ? new Date().toISOString().slice(0,10) : '—';

  ammoFill.style.width = `${(GAME.ammo/GAME.ammoMax)*100}%`;
  heatFill.style.width = `${(GAME.heat/GAME.heatMax)*100}%`;
  focusFill.style.width = `${(GAME.focus/GAME.focusMax)*100}%`;
}

/* ================= Main Loop ================= */
function step(){
  const now = performance.now();
  let dt = (now - GAME.last)/1000; GAME.last = now;
  dt = Math.min(dt, 0.033); // clamp long frames for stability

  // Apply focus (slow‑mo)
  if(GAME.focusActive){
    dt *= 0.35;
    GAME.focus = Math.max(0, GAME.focus - 40*dt);
    if(GAME.focus<=0){ GAME.focusActive=false; }
  }

  if(GAME.state==='play'){
    updateGame(dt);
    renderGame(dt);
  }else{
    // Still draw animated background for menu
    renderGame(0);
  }

  requestAnimationFrame(step);
}

function updateGame(dt){
  GAME.time += dt;

  // Ammo reload
  GAME.ammoTimer += dt;
  const reloadRate = 1 / (GAME.ammoReload * (1 - SAVE.upgrades.reload*0.06));
  if(GAME.ammoTimer>=reloadRate && GAME.ammo<GAME.ammoMax){
    GAME.ammo++; GAME.ammoTimer=0;
  }
  // Heat / Overheat recovery
  GAME.heat = Math.max(0, GAME.heat - 16*dt);
  if(GAME.overheated && GAME.heat <= GAME.heatMax*0.55){
    GAME.overheated=false;
    if(!SAVE.ach.noOverheat) SAVE.ach.noOverheat = true;
  }

  // Move shots; cull; (detonate on second click handled in detonateNearest)
  for(let i=GAME.shots.length-1;i>=0;i--){
    const s = GAME.shots[i]; if(!s.alive){ GAME.shots.splice(i,1); continue; }
    s.update(dt);
  }

  // Explosions evolve
  for(let i=GAME.explosions.length-1;i>=0;i--){
    const e = GAME.explosions[i]; if(!e.alive){ GAME.explosions.splice(i,1); continue; }
    e.update(dt);
  }

  // Enemies move; cull dead
  for(let i=GAME.enemies.length-1;i>=0;i--){
    const e = GAME.enemies[i]; if(!e.alive){ GAME.enemies.splice(i,1); continue; }
    e.update(dt);
  }

  // Particles
  for(let i=GAME.particles.length-1;i>=0;i--){
    const p = GAME.particles[i]; p.t+=dt; if(p.t>p.life){ GAME.particles.splice(i,1); continue; }
    p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= (1 - 1.8*dt); p.vy *= (1 - 1.8*dt); p.vy += 10*dt;
  }

  // Resonance fields
  // (drawn in render; advanced in drawResonances)

  // Apply blast damage
  handleBlastDamage();

  // Director spawns
  updateDirector(dt);

  // Wave advance: every N seconds bumps wave
  if(GAME.time >= 25 + (GAME.wave-1)*8){
    // perfect wave achievement
    if(GAME.statsWavePerfect && aliveCities()===3 && !SAVE.ach.perfectWave) SAVE.ach.perfectWave = true;
    GAME.wave++; GAME.time = 0; GAME.statsWavePerfect = true;
    // reward ammo + score
    GAME.ammo = Math.min(GAME.ammoMax, GAME.ammo + 3);
    GAME.score += 100 + GAME.wave*25;
  }

  // Combo timer
  if(GAME.comboTimer>0){
    GAME.comboTimer -= dt; if(GAME.comboTimer<=0){ GAME.combo=0; }
  }

  // Game over?
  if(aliveCities()<=0){
    endGame();
  }

  updateHud();
}

function renderGame(dt){
  const W = GAME.width(), H = GAME.height();

  // camera shake
  if(CAMERA.shake>0){ CAMERA.shake *= 0.9; } else { CAMERA.shake=0; }
  const sx = (GAME.rng()*2-1) * CAMERA.shake, sy=(GAME.rng()*2-1)*CAMERA.shake;
  ctx.setTransform(1,0,0,1, sx, sy);

  // background space & grid
  ctx.clearRect(-10,-10,W+20,H+20);
  // stars parallax
  for(let i=0;i<40;i++){
    const px = (i*97 % W), py=(i*71 % H);
    ctx.fillStyle = `rgba(255,255,255,${0.03 + (i%5)*0.01})`;
    ctx.fillRect(px, py, 2*DPR, 2*DPR);
  }
  // faint horizon glow
  const g= ctx.createLinearGradient(0, H*0.7, 0, H);
  g.addColorStop(0, 'rgba(95,210,255,.0)'); g.addColorStop(1, 'rgba(95,210,255,.12)');
  ctx.fillStyle=g; ctx.fillRect(0,H*0.7,W,H*0.3);

  // Draw resonance fields
  drawResonances(dt);

  // shots
  for(const s of GAME.shots){ s.draw(); }

  // explosions
  for(const e of GAME.explosions){ e.draw(); }

  // enemies
  for(const e of GAME.enemies){ e.draw(); }

  // particles
  for(const p of GAME.particles){
    const a = 1 - (p.t/p.life);
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.fillStyle = (p.mode==='shield')?`rgba(255,198,88,${.5*a})`:`rgba(255,98,162,${.6*a})`;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.size,0,TAU); ctx.fill();
    ctx.restore();
  }

  // convoy (player & cities)
  drawConvoy(dt);

  // aim reticle
  ctx.save();
  ctx.globalCompositeOperation='lighter';
  const r = 8*DPR + Math.sin(GAME.time*6)*1.2*DPR;
  ctx.strokeStyle='rgba(95,210,255,.55)'; ctx.lineWidth=1.2*DPR;
  ctx.beginPath(); ctx.arc(mouse.x,mouse.y,r,0,TAU); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(mouse.x-r*1.6, mouse.y); ctx.lineTo(mouse.x-r*0.7,mouse.y);
  ctx.moveTo(mouse.x+r*1.6, mouse.y); ctx.lineTo(mouse.x+r*0.7,mouse.y);
  ctx.moveTo(mouse.x, mouse.y-r*1.6); ctx.lineTo(mouse.x,mouse.y-r*0.7);
  ctx.moveTo(mouse.x, mouse.y+r*1.6); ctx.lineTo(mouse.x,mouse.y+r*0.7);
  ctx.stroke();
  ctx.restore();
}

/* ================= Menu & Panels ================= */
const overlay = document.getElementById('overlay');
const menuBtn = document.getElementById('menuBtn');
menuBtn.onclick = ()=> toggleMenu();

function toggleMenu(force){
  const show = force ?? !overlay.classList.contains('show');
  overlay.classList.toggle('show', show);
  GAME.state = show ? (GAME.state==='play' ? 'pause':'menu') : 'play';
}

document.getElementById('playBtn').onclick = ()=>{ resetGame('endless-'+Date.now()); startGame(false); };
document.getElementById('dailyBtn').onclick= ()=>{ const d = new Date().toISOString().slice(0,10); resetGame('daily-'+d, true); startGame(true); SAVE.stats.dailies++; saveAll(); };
document.getElementById('howBtn').onclick = ()=> { /* already present in panel */ };
document.getElementById('upgBtn').onclick = ()=> { scrollToSection('Upgrades'); };
document.getElementById('achBtn').onclick = ()=> { alert('Achievements: \n• First Blood\n• Chain ×10\n• No Overheat\n• Perfect Wave'); };
document.getElementById('setBtn').onclick = ()=> { scrollToSection('Settings'); };
document.getElementById('resetBtn').onclick = ()=> { if(confirm('Reset all progress?')){ localStorage.removeItem(SAVE_KEY); location.reload(); } };

function scrollToSection(titleText){
  // Simple helper (panel is short; no complex nav needed)
}

/* Build Upgrades & Settings UI */
function renderUpgrades(){
  const U = SAVE.upgrades;
  const el = document.getElementById('upgrades');
  const points = Math.min(9999, Math.floor(SAVE.stats.totalScore/1500));
  function row(label, key, desc){
    const lvl = U[key]|0, cost = (lvl+1);
    const can = points >= cost && lvl<10;
    return `<div class="row">
      <div>
        <div><b>${label}</b> <span class="tag">Lv ${lvl}/10</span></div>
        <div class="muted">${desc}</div>
      </div>
      <div>
        <button data-upg="${key}" class="cta ${can?'primary':''}" ${can?'':'disabled'}>Buy (${cost})</button>
      </div>
    </div>`;
  }
  el.innerHTML = row('Blast Radius','radius','Bigger explosions; stronger resonance fields.')
    + row('Reload','reload','Faster interceptor regeneration.')
    + row('Interceptor Speed','speed','Quicker reach to your detonation point.')
    + row('Focus Capacity','focus','Longer slow‑mo window.');
  // Bind
  el.querySelectorAll('button[data-upg]').forEach(btn=>{
    btn.onclick=()=>{
      const key = btn.getAttribute('data-upg'); const lvl = U[key]|0; const cost=lvl+1;
      if(points>=cost && lvl<10){ U[key]=lvl+1; SAVE.stats.totalScore -= cost*1500; saveAll(); renderUpgrades(); }
    };
  });
}
function renderSettings(){
  const S = SAVE.settings;
  const el = document.getElementById('settings');
  el.innerHTML = `
    <div class="row"><div>Particles</div><div><input type="checkbox" id="setParticles" ${S.particles?'checked':''}></div></div>
    <div class="row"><div>Screen Shake</div><div><input type="checkbox" id="setShake" ${S.shake?'checked':''}></div></div>
    <div class="row"><div>Flashes</div><div><input type="checkbox" id="setFlashes" ${S.flashes?'checked':''}></div></div>
    <div class="row"><div>Colorblind‑friendly palette</div><div><input type="checkbox" id="setCB" ${S.colorblind?'checked':''}></div></div>
    <div class="row"><div>Volume</div><div><input type="range" id="setVol" min="0" max="1" step="0.01" value="${S.volume}"></div></div>
    <div class="row"><div>Difficulty</div>
      <div>
        <select id="setDiff">
          <option ${S.difficulty==='relaxed'?'selected':''} value="relaxed">Relaxed</option>
          <option ${S.difficulty==='normal'?'selected':''} value="normal">Normal</option>
          <option ${S.difficulty==='hard'?'selected':''} value="hard">Hard</option>
        </select>
      </div>
    </div>
  `;
  el.querySelector('#setParticles').onchange = e=> { S.particles = e.target.checked; saveAll(); };
  el.querySelector('#setShake').onchange     = e=> { S.shake = e.target.checked; saveAll(); };
  el.querySelector('#setFlashes').onchange   = e=> { S.flashes = e.target.checked; saveAll(); };
  el.querySelector('#setCB').onchange        = e=> { S.colorblind = e.target.checked; applyPalette(); saveAll(); };
  el.querySelector('#setVol').oninput        = e=> { S.volume = +e.target.value; masterGain.gain.value=S.volume; saveAll(); };
  el.querySelector('#setDiff').onchange      = e=> { S.difficulty = e.target.value; saveAll(); };
}
function renderStats(){
  const st = SAVE.stats;
  document.getElementById('stats').innerHTML = `
    <div class="row"><div>Games Played</div><div>${st.games|0}</div></div>
    <div class="row"><div>Best Score</div><div>${st.best|0}</div></div>
    <div class="row"><div>Total Score</div><div>${st.totalScore|0}</div></div>
    <div class="row"><div>Enemies Destroyed</div><div>${st.enemies|0}</div></div>
    <div class="row"><div>Chains Built</div><div>${st.chains|0}</div></div>
    <div class="row"><div>Dailies Entered</div><div>${st.dailies|0}</div></div>
  `;
}
function applyPalette(){
  if(SAVE.settings.colorblind){
    document.documentElement.style.setProperty('--accent','#7bd389');
    document.documentElement.style.setProperty('--accent2','#4ea1ff');
    document.documentElement.style.setProperty('--good','#00d08a');
    document.documentElement.style.setProperty('--bad','#ff6b6b');
  }else{
    document.documentElement.style.setProperty('--accent','#5fd2ff');
    document.documentElement.style.setProperty('--accent2','#9b5cff');
    document.documentElement.style.setProperty('--good','#3cff9e');
    document.documentElement.style.setProperty('--bad','#ff5f7a');
  }
}
function openMenu(){
  renderUpgrades(); renderSettings(); renderStats();
  toggleMenu(true);
}
function startGame(isDaily){
  overlay.classList.remove('show');
  GAME.state='play'; SAVE.stats.games++; saveAll();
}
function endGame(){
  GAME.state='over';
  SAVE.stats.best = Math.max(SAVE.stats.best|0, GAME.score|0);
  SAVE.stats.totalScore += GAME.score|0;
  saveAll();
  setTimeout(()=>{ openMenu(); alert('Game Over — Score: '+GAME.score); }, 100);
}
function saveAll(){ localStorage.setItem(SAVE_KEY, JSON.stringify(SAVE)); }

/* ================= Kickoff ================= */
applyPalette();
openMenu();
requestAnimationFrame(step);
</script>
</body>
</html>
